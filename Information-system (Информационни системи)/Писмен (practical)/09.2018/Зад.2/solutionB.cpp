#include <iostream>

class Counter {
private:
    static int instanceCounter;
public:
    Counter(){
        instanceCounter++;
    }

    ~Counter(){
        instanceCounter--;
    }

    Counter(const Counter& other){
        instanceCounter++;
    }

    Counter& operator=(const Counter& other){
        if (this != &other) {
        }
        return *this;
    }

    static int GetObjCount(){
        return instanceCounter;
    }
};

int Counter::instanceCounter = 0;

class Derived : public Counter { };

int main() {
    Derived d1;
    std::cout << Derived::GetObjCount();
        // горният ред ще изведе 1

    Counter c;
    std::cout << Counter::GetObjCount();
        // горният ред ще изведе 2

    Counter* p = new Derived;
    std::cout << Counter::GetObjCount();
        // горният ред ще изведе 3

    std::cout << Derived::GetObjCount();
        // горният ред ще изведе 3

    delete p;
    std::cout << Counter::GetObjCount();
        // горният ред ще изведе 2

    std::cout << Derived::GetObjCount();
        // горният ред ще изведе 2


    /* Тук обосновете отговора си:

        Програмата започва създавайки обект от тип Derived.
        Всяко дете в една ООП йерархия вика бащините конструктори,
        затова очакваното поведение в тази ситуация е, че ще се извика
        конструктура на класа Counter първо, който от своя страна ще увеличи
        променливата брояч с 1. Така променливата брояч започваща със стойност 0
        вече има стойност 1. Затова на следващия ред резултата ще бъде 1,
        когато благодарение на публичното наследяване чрез класа Derived
        извикаме функцията GetObjCount().

        Следващите два реда не изискват много обяснение - създава
        се Counter обект, конструктора му вътрешни увеличава брояча веднъж
        и така на следващия ред получаваме 2.

        По-нататък забелязваме създаване на указател от тип Counter (бащин клас),
        сочещ към новосъздаден обект от тип Derived (клас наследник) - свойство разрешено
        и типично в ООП света. Както се разбира от последното изречение
        изисква се създаването на нов Derived обект, процес, който
        вече знаем, че включва учеличаване на брояча веднъж. Така на следващия
        ред ще получим 3.

        След това отново ще се изпише 3 на екрана, защото не сме създавали
        или изтривали обекти от тип Counter или Derived.

        И финално delete p ще изтрие обекта сочен от Counter указателя, а именно
        обекта от тип Derived. Това действие изисква извикване на деструктора на
        класа Counter (ако деструктора на Counter беше виртуален, щеше да се извика и
        хипотетичния деструктор на Derived).
        Затова очаквания резултат е, че при извикването на бащиния деструктор
        променливата брояч ще се намали с 1. И така, следващите два прогргамни израза,
        които пишат на стандартния изход ще изкарат 2 като резултат от викането
        на функцията GetObjCount().

     */
}

